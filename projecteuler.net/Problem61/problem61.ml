(**
   Problem 61

   Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
   all figurate (polygonal) numbers and are generated by the following formulae:

   Triangle     P3,n=n(n+1)/2    1, 3, 6, 10, 15, ...
   Square       P4,n=n2          1, 4, 9, 16, 25, ...
   Pentagonal   P5,n=n(3n-1)/2    1, 5, 12, 22, 35, ...
   Hexagonal    P6,n=n(2n-1)      1, 6, 15, 28, 45, ...
   Heptagonal   P7,n=n(5n-3)/2    1, 7, 18, 34, 55, ...
   Octagonal    P8,n=n(3n-2)      1, 8, 21, 40, 65, ...

   The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

   1. The set is cyclic, in that the last two digits of each number is
      the first two digits of the next number (including the last number with the first).
   
   2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281),
      and pentagonal (P5,44=2882), is represented by a different number in the set.
 
   3. This is the only set of 4-digit numbers with this property.

   Find the sum of the only ordered set of six cyclic 4-digit numbers
   for which each polygonal type: triangle, square, pentagonal, hexagonal,
   heptagonal, and octagonal, is represented by a different number in the set.
*)


module A : sig

  (** polygonal functions *)
  val triangle : int -> int
  val square : int -> int
  val pentagonal : int -> int
  val hexagonal : int -> int
  val heptagonal : int -> int
  val octagonal : int -> int

  val find4digits : (int -> int) -> int list
  val all4digits : (int -> int) list -> int list list

  val is_next : int -> int -> bool
  val find_all_next : int -> int list -> int list

  val test : unit -> unit

end = struct

  let triangle n = (n*n + n) / 2
  let square n = n*n
  let pentagonal n = (3*n*n - n) / 2
  let hexagonal n = 2*n*n - n
  let heptagonal n = (5*n*n - 3*n) / 2
  let octagonal n = 3*n*n - 2*n

  let polygonals = [triangle; square; pentagonal; heptagonal; heptagonal; octagonal];;

  let find4digits polygonal = 
    let rec find4digits accu n =
      match n with 
      | n when polygonal n > 9999 -> List.rev accu
      | n when polygonal n < 1000 -> find4digits accu (n+1)
      | _ -> find4digits ((polygonal n)::accu) (n+1)
    in
    find4digits [] 1
  ;;

  let all4digits polygonals =
    let rec all4digits accu = function
      | [] -> List.rev accu
      | p::ps -> all4digits ((find4digits p)::accu) ps
    in
    all4digits [] polygonals
  ;;

  let is_next curr cand =
    match curr, cand with
    | curr, _ when curr < 1000 -> false
    | _, cand when cand < 1000 -> false
    | curr, _ when curr > 9999 -> false
    | _, cand when cand > 9999 -> false
    | _, _ ->
        let base = String.sub (string_of_int curr) 2 3 in
        (String.sub (string_of_int cand) 0 1) = base
  ;;

  let find_all_next n l = List.find_all (is_next n) l;;

  let rec print_int_list = function
    | [] -> ()
    | n::ns ->
        let _ = Printf.printf "%d\n" n in
        print_int_list ns
  ;;

  let rec print_int_list_list = function
    | [] -> ()
    | ns::nss -> 
        begin
          Printf.printf "--------\nLength : %d\n--------\n" (List.length ns);
          print_int_list ns;
          print_int_list_list nss
        end
  ;;

  let test () =
    let digits = all4digits polygonals in
    let _ = print_int_list_list digits in
    ()
  ;;


end;;

A.test ();;
